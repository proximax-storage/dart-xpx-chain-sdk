/*
 * Copyright 2018 ProximaX Limited. All rights reserved.
 * Use of this source code is governed by the Apache 2.0
 * license that can be found in the LICENSE file.
 */

part of xpx_chain_sdk.model.message;

/// An encrypted message model defines a secure message that has been encrypted using
/// the Symbol's SDK libraries.
///
/// Please note:
/// The strategy to encrypt and decrypt should be consistent between the different SDKs.
/// A client may send a transaction using a different encryption strategy than the recipient.
/// Even though the same encryption algorithm is used, the outcome may still be different
/// depending on the encoding process.
///
/// The encryption strategy this SDK uses is UTF-8 and hex encodings:
/// "plain text" string -> utf8 byte array -> encrypted byte array -> hex string
class EncryptedMessage extends Message {
  // private constructor
  EncryptedMessage._(String encryptedPayload)
      : super(MessageType.encrypted, HexUtils.hexToBytes(encryptedPayload));

  // Developer note:
  // If one to allow to create a EncryptedMessage object using this constructor, make sure to
  // put in place a check to see if the payload (in bytes) is actually encrypted or not.
  //  factory EncryptedMessage(final Uint8List encryptedPayload) {
  //    if (encryptedPayload == null) {
  //      throw new ArgumentError('The message payload must not be null');
  //    }
  //
  //    return new EncryptedMessage._(encryptedPayload);
  //  }

  /// Creates an encrypted message from [plainTextMessage].
  ///
  /// The message is encrypted using a shared key generated by the [senderPrivateKey] and
  /// the [recipientPublicKey]. The recipient can decrypt this message using this shared key by
  /// taking the sender's public key and the recipient's public key.
  static Future<EncryptedMessage> create(String plainTextMessage,
      String senderPrivateKey, String recipientPublicKey,
      [isHexMessage = false]) async {
    ArgumentError.checkNotNull(plainTextMessage);

    // Encrypts the message
    final encryptedPayload = await crypto.encryptMessage(
        plainTextMessage,
        HexUtils.getBytes(senderPrivateKey),
        HexUtils.tryGetBytes(recipientPublicKey)!,
        isHexMessage);

    return EncryptedMessage._(ByteUtils.bytesToHex(encryptedPayload));
  }

  /// Creates an encrypted message from [payload].
  ///
  /// The [payload] is a hex encoded string.
  static EncryptedMessage fromPayload(final String payload) {
    if (!HexUtils.isHex(payload)) {
      throw new ArgumentError('message payload is not a valid hex string');
    }

    return new EncryptedMessage._(payload);
  }

  /// Decrypts an [encryptedMessage] sent for the [NetworkType].
  ///.
  /// Returns a UTF-8 formatted string.
  static Future<PlainMessage> decrypt(EncryptedMessage encryptedMessage,
      String recipientPrivateKey, String senderPublicKey,
      [isHexMessage = false]) async {
    ArgumentError.checkNotNull(encryptedMessage);
    ArgumentError.checkNotNull(encryptedMessage.payload);

    final decrypted = await crypto.decryptMessage(
        encryptedMessage.payload,
        HexUtils.hexToBytes(recipientPrivateKey),
        HexUtils.hexToBytes(senderPublicKey));

    if (isHexMessage) {
      return PlainMessage(payload: ByteUtils.bytesToHex(decrypted));
    }
    return PlainMessage(
        payload: ByteUtils.bytesToUtf8String(Uint8List.fromList(decrypted)));
  }

  @override
  String get payloadAsString => hex.encode(payload);

  @override
  String toString() =>
      '{type: $type, payload: ${ByteUtils.bytesToHex(payload)}}';
}
