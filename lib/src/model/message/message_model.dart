part of xpx_chain_sdk.message;

class Message {
  Message(this.type, this.payload);

  Message.fromDTO(MessageDTO dto) {
    if (dto?._payload == null) {
      return;
    }
    if (_hexadecimal.hasMatch(dto._payload)) {
      payload = hex.decode(dto._payload);
    } else {
      payload = Uint8List.fromList(dto._payload.codeUnits);
    }
    type = MessageType.getType(dto.type);
  }

  MessageType type;
  Uint8List payload;

  String get payloadAsString => utf8.decode(payload);

  @override
  String toString() => '${toJson()}';

  Map<String, dynamic> toJson() {
    final data = <String, dynamic>{};
    data['type'] = type;
    data['payload'] = payloadAsString;
    return data;
  }
}

class MessageType {
  const MessageType(this.value);

  static const String invalidType = 'invalid message type';

  static const MessageType unencrypted = MessageType(0x00);

  static const MessageType encrypted = MessageType(0x01);

  static final List<MessageType> values = <MessageType>[unencrypted, encrypted];

  final int value;

  static MessageType getType(final int value) {
    for (var i = 0; i < values.length; i++) {
      if (values[i].value == value) {
        return values[i];
      }
    }

    throw ArgumentError(invalidType);
  }

  @override
  String toString() => '$value';

  Map<String, dynamic> toJson() => {'value': value};
}

class PlainMessage extends Message {
  factory PlainMessage({final Uint8List bytes, final String payload}) {
    if (payload == null && bytes == null) {
      throw ArgumentError('The message payload must not be null');
    }

    if (bytes != null && bytes.isNotEmpty) {
      return PlainMessage._(bytes);
    }

    if (_hexadecimal.hasMatch(payload)) {
      return PlainMessage._(Uint8List.fromList(payload.codeUnits));
    }
    return PlainMessage._(Uint8List.fromList(payload.codeUnits));
  }

  PlainMessage._(Uint8List payload) : super(MessageType.unencrypted, payload);

  static final PlainMessage empty = PlainMessage(payload: '');
}

/// An encrypted message model defines a secure message that has been encrypted using
/// the Symbol's SDK libraries.
///
/// Please note:
/// The strategy to encrypt and decrypt should be consistent between the different SDKs.
/// A client may send a transaction using a different encryption strategy than the recipient.
/// Even though the same encryption algorithm is used, the outcome may still be different
/// depending on the encoding process.
///
/// The encryption strategy this SDK uses is UTF-8 and hex encodings:
/// "plain text" string -> utf8 byte array -> encrypted byte array -> hex string
class EncryptedMessage extends Message {
  // private constructor
  EncryptedMessage._(String encryptedPayload) : super(MessageType.encrypted, HexUtils.hexToBytes(encryptedPayload));

  // Developer note:
  // If one to allow to create a EncryptedMessage object using this constructor, make sure to
  // put in place a check to see if the payload (in bytes) is actually encrypted or not.
  //  factory EncryptedMessage(final Uint8List encryptedPayload) {
  //    if (encryptedPayload == null) {
  //      throw new ArgumentError('The message payload must not be null');
  //    }
  //
  //    return new EncryptedMessage._(encryptedPayload);
  //  }

  /// Creates an encrypted message from [plainTextMessage].
  ///
  /// The message is encrypted using a shared key generated by the [senderPrivateKey] and
  /// the [recipientPublicKey]. The recipient can decrypt this message using this shared key by
  /// taking the sender's public key and the recipient's public key.
  static EncryptedMessage create(String plainTextMessage, String senderPrivateKey, String recipientPublicKey,
      [isHexMessage = false]) {
    ArgumentError.checkNotNull(plainTextMessage);

    // Encrypts the message
    final String encryptedPayload =
        crypto.encryptMessage(plainTextMessage, senderPrivateKey, recipientPublicKey, isHexMessage);

    return EncryptedMessage._(encryptedPayload);
  }

  /// Creates an encrypted message from [payload].
  ///
  /// The [payload] is a hex encoded string.
  static EncryptedMessage fromPayload(final String payload) {
    if (!HexUtils.isHex(payload)) {
      throw new ArgumentError('message payload is not a valid hex string');
    }

    return new EncryptedMessage._(payload);
  }

  /// Decrypts an [encryptedMessage] sent for the [networkType].
  ///
  /// Returns a UTF-8 formatted string.
  static PlainMessage decrypt(EncryptedMessage encryptedMessage, String recipientPrivateKey, String senderPublicKey,
      [isHexMessage = false]) {
    ArgumentError.checkNotNull(encryptedMessage);
    ArgumentError.checkNotNull(encryptedMessage.payload);

    final String decrypted = crypto.decryptMessage(
        ByteUtils.bytesToHex(encryptedMessage.payload), recipientPrivateKey, senderPublicKey, isHexMessage);
    return PlainMessage(payload: decrypted);
  }

  @override
  String get payloadAsString => hex.encode(payload);

  @override
  String toString() => '{type: $type, payload: ${ByteUtils.bytesToHex(payload)}}';
}
